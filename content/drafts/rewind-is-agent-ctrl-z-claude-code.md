---
title: "Rewind 不是撤销文件：把 Agent 的 Ctrl+Z 从‘代码’升级到‘执行’"
date: 2026-02-07
status: draft
tags: [agent, claude-code, rewind, checkpoint, workflow]
---

> 这篇写给正在把 Agent 接进真实流水线的人：你已经不再担心“它能不能写代码”，而是更担心“它做错了能不能回得来”。

## 1）一个很具体的现场：我不是想撤销文件，我是想撤销“它做过的事”

想象一个常见任务：

- 你让 Claude Code 帮你把一段脚本接进 CI；
- 它跑了测试、改了配置、顺手更新了依赖；
- 然后你发现：某一步的假设错了（环境变量名、目录结构、或第三方接口限流逻辑）。

这时你最想要的“撤销”是什么？

不是把 `package.json` 或某个文件回滚到旧版本那么简单。因为 Agent 的行为往往是：

- 写/删文件（可逆）；
- 跑命令、生成产物、写缓存（部分可逆）；
- 触发外部动作：发消息、创建工单、更新线上配置、调用支付/发券/发邮件（很多不可逆）。

如果你做过 **OpenClaw + WeChat** 这种“写完代码就真的去发”的流水线，你会非常熟悉这个痛点：

- 代码改错了还能 git reset；
- 但**消息发错了**，对方已经看到了；
- **群里 @错人**，社死是不可逆的；
- “再发一条解释”不叫回滚，只是补救。

所以我们真正想要的不是“撤销文件（undo files）”，而是：

> 能不能把 Agent 的执行过程当成一段可回放、可定位、可恢复的事务（transaction）？

这就是 Claude Code 里 `/rewind` 这类能力最容易被误解、但也最值钱的地方。

## 2）先把概念掰清楚：rewind ≠ 撤销文件

在很多人的心智模型里，rewind = “回到上一步，文件恢复”。

但在 Agent 世界里，这个理解会让你误判它的边界：

- **文件撤销**是“状态回滚”；
- **rewind**更像是“执行控制”：把 Agent 的工作切成一段段可追溯的步骤，在某个检查点（checkpoint）上重新选择路径。

更准确地说，它是三件事的组合：

1. **检查点（checkpoint）**：记录“我当时做决策时看到了什么、打算做什么、做到了哪里”。
2. **可追溯（traceability）**：你能回答“为什么会走到这一步”。（输入、工具调用、输出、变更摘要）
3. **可恢复（recoverability）**：从某个点回去，不是把世界擦掉，而是**把后续步骤作废**，并允许你重跑/改计划/换策略。

注意：

- rewind 不等同于“抹掉一切痕迹”。真实世界里很多动作没有“撤销键”。
- rewind 的价值在于：**把不可逆的风险显式化**，并尽可能让可逆部分变得可逆、让不可逆部分变得可补偿。

## 3）为什么产品上它很重要：把“试错”变成“可控试错”

我用一句很朴素的话总结 `/rewind` 的产品价值：

> 让你敢让 Agent 去做事。

没有 rewind/检查点，真实流水线里常见的是两种极端：

- **保守派**：Agent 只负责写建议，不允许执行（价值打折，但安全）；
- **莽夫派**：Agent 直接 apply 一切（效率高，但迟早出事故）。

rewind 的意义在中间：

- 你允许它跑、允许它试；
- 但你要求它“每走几步就打点”，并且对外部动作给出“可补偿/可确认/可幂等”的设计。

对团队协作也很现实：

- 新人接手一个 Agent 任务，不需要从头理解全部上下文；
- 只要找到关键 checkpoint，看当时的证据（日志、diff、工具调用），就能判断下一步。

## 4）最小可迁移工程架构（只保留你今天就能用的部分）

不讲宏大框架，只给一个“今天就能塞进你项目里”的最小架构。

### 4.1 基本对象：Run / Step / Checkpoint

把一次 Agent 执行当成一个 `Run`：

- `run_id`
- `goal`：用户目标
- `context`：关键输入（配置、环境、凭据引用，不要直接存密钥）
- `steps[]`

每个 `Step` 至少记录：

- `step_id` / `index`
- `intent`：这一步想做什么（自然语言即可）
- `plan`：要调用哪些工具/命令
- `observations`：这一步看到的关键信息摘要（命令输出/页面状态）
- `artifacts`：diff、生成文件列表、外部请求参数摘要
- `status`: planned | dry_run_ok | applied | failed | compensated | skipped

`Checkpoint` 不需要很神秘：

- 可以就是“某个 step 的边界”
- 或者每 N 步自动打点
- 或者遇到高风险动作（外部写入）前强制打点

### 4.2 两阶段执行：dry-run → apply

要让 rewind 真的可用，一个关键技巧是把“决定”和“执行”拆开。

**Dry-run（演练）**阶段做这些事：

- 生成明确计划（将要改哪些文件、将要调用哪些外部 API、将要发什么消息）
- 尽可能进行只读验证（lint/test、读取页面、查询接口状态）
- 产出“可审阅的变更集”：
  - 文件 diff
  - 外部动作列表（带幂等 key）
  - 风险提示（不可逆项）

**Apply（执行）**阶段才真的落地：

- 写文件、跑命令
- 调用外部 API / 发消息
- 写入 step 的执行结果与回执

### 4.3 rewind / resume 的最小语义

**rewind：**

- 选择一个 `step_k` 作为目标
- 将 `k` 之后的 steps 标记为 `skipped/voided`
- 将 workspace 回到 `step_k` 的 snapshot（例如 `git reset --hard <hash>`）
- 允许你修改计划/提示词/参数
- 重新从 `k+1` 开始生成新的步骤

**resume：**

- 继承必要状态（已创建的工单 ID / 消息 ID）
- 读取 outbox，保证“重试不重复”

### 4.4 外部不可逆动作：补偿 / 幂等 / 标记

rewind 最难的不是文件，而是“现实世界”。最小可迁移的策略分三类：

**1) 补偿动作（Compensation）**
- 创建工单 → 关闭工单
- 创建 PR → 关闭 PR
- 发公告 → 发更正 + 标记原公告作废

**2) 幂等（Idempotency）**
- 为每个外部写入动作生成 `idempotency_key`
- 对方 API 不支持也没关系：你自己做一层 `outbox` 记录，执行前先查是否已发送过

**3) 标记 + 人工确认（Human-in-the-loop）**
- 先 `PENDING_CONFIRMATION`
- 人确认后再 apply

一句话：把不可逆动作尽量后置，把错误暴露在可撤回的阶段。

## 5）对照我们踩过的坑：为什么“只有 git”不够

在 OpenClaw+WeChat 这种流水线里，我们遇到过几类典型问题：

- **命令执行的副作用**：跑一次脚本生成临时文件/缓存，git 没法覆盖所有角落。
- **异步/延迟回执**：发送请求成功但回执晚到，下一步已经开始。
- **不确定状态**：超时导致“不知道发没发”，重试导致重复。

这些坑本质上都在提醒你：

> rewind 的对象是“执行序列”，不是“代码目录”。

你需要的不是更强的撤销文件工具，而是更好的执行记录与控制面。

## 6）一个可执行的小实验：给你的 Agent 加一个“简化版 rewind”

你可以用 30–60 分钟做一个最小实验，把 rewind 的核心感觉做出来。

**目标：** 让你的 Agent 执行一个带外部动作的任务（例如“发一条测试消息/创建一个 issue”），并支持：

- 每步落盘
- dry-run 预览
- rewind 到某一步重新来
- 重试不重复（幂等/outbox）

**最小步骤：**

1）把 workspace 纳入 git
- 这是最便宜的 snapshot。
- 每个 checkpoint 自动 `git add -A && git commit -m "checkpoint <run_id> <step>"`（实验阶段可以这么粗暴）。

2）实现一个 `outbox.jsonl`
- 外部写入前先记录 `idempotency_key / action_type / payload_hash / status`
- 成功后写回 `receipt`（message_id / issue_id）

3）实现 dry-run
- 文件变更：`git diff` 作为预览
- 外部动作：只生成 payload，不发送

4）实现 apply
- 发送前查 outbox 是否已有成功记录
- 没有才发

5）实现 rewind
- 选择一个 checkpoint commit
- `git reset --hard <commit>`
- 将 steps[k+1..] 标记为 voided

6）实现 resume
- 从 step_k 读取上下文（例如已创建的资源 ID）
- 继续 dry-run/apply

**你会得到什么：**

- 你会明显感觉到：Agent 的“可控性”来自执行控制，而不是提示词更聪明。
- 你会开始自然地问：哪些动作应该后置？哪些必须人工确认？哪些需要幂等？

---

## 三句总结（写给忙的人）

- rewind 不是把文件回到过去，而是把 **Agent 的执行历史** 回到一个可重新分叉的检查点。
- 关键工程手段是：**checkpoint + dry-run + apply + outbox/幂等 + 补偿/确认**。
- 你越早把外部不可逆动作抽成统一层，rewind/resume 就越容易做对。
