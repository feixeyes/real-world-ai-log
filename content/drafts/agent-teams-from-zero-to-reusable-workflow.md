# Agent Teams：从 0 到可复用的并行工作流（实践版）

> 这不是在讲“更聪明的模型”，而是讲**更可交付的流程**。
> 如果单 agent 经常卡在“读不清 / 写过头 / 返工多”，你需要的是分工与验收。

---

## 1) 痛点开场：单 agent 为什么会失控
我见过最典型的三种失控：

1. **读不清**：理解偏了，后面越写越歪
2. **写过头**：顺手改太多，回滚成本暴涨
3. **返工多**：每轮都要你纠正细节，收敛很慢

这些问题本质上不是模型不够聪明，而是**没有分工与验收机制**。

---

## 2) 角色分工清单（可直接复制）

**A｜读代码/建模**
- 输出：入口/数据流/边界条件
- 目标：把“我要改什么”变成“我该改哪里”

**B｜写实现**
- 输出：最小可运行实现 + 变更摘要
- 目标：在 A 的结论上实现，不额外扩张范围

**C｜验收/测试**
- 输出：最小验证命令 + 风险点清单
- 目标：把“交付”变成可验收交付

> 这 3 个角色是最小可用版本。你可以只用 A+B，也可以加 C 做收敛。

---

## 3) 工作流模板（可复用流程）

**步骤 1：任务拆分**
- 产物：任务说明 + DoD + 禁止项

**步骤 2：并行执行**
- A：读代码/建模
- B：写实现
- C：写验收/测试

**步骤 3：汇合审查**
- 对齐 A 的“定位”与 B 的“改动范围”
- C 给出最小验证命令

**步骤 4：验收交付**
- 执行最小验证
- 输出变更摘要 + 风险与回滚

> 关键点：**每一步都要产出可验证的 artifact**。

---

## 4) 实操案例（一个小功能任务）

**任务**：给现有脚本加一个 `--dry-run`，打印将要执行的步骤，但不真正执行。

**A（读代码/建模）产出**
- 入口文件：`scripts/xxx.mjs`
- 主流程：解析参数 → 执行步骤 → 输出结果
- 风险：参数解析散落在多个函数，需统一处理

**B（写实现）产出**
- 新增 `--dry-run` 参数
- 主流程中提前 `return`，只打印步骤
- 变更摘要：改了哪几个函数，为什么这样改

**C（验收/测试）产出**
- 最小验证命令：
  - `node scripts/xxx.mjs --dry-run`
- 预期输出：列出 3–5 个步骤但不执行
- 风险：dry-run 分支不应修改任何外部状态

> 这样一轮下来，任务从“感觉能用”变成“可验收能用”。

---

## 5) 复盘：并行协作的 3 个坑

1) **上下文漂移**
- A 的结论没同步给 B，B 还是在猜
- 解法：A 的输出必须结构化（入口/数据流/边界）

2) **变更冲突**
- B 改了范围，C 的验证就失效
- 解法：禁止项写清楚，B 不扩张范围

3) **成本失控**
- 开太多 agent，收益被 token 消耗抵消
- 解法：只在“复杂任务/返工高”时开 Team

---

## 6) 结论：Agent Teams 的性价比阈值

**值得开 Team 的场景**
- 你对代码库不熟
- 任务涉及多个模块
- 返工成本高

**不值得开 Team 的场景**
- 任务很小（改一行/调参数）
- 你已经非常熟悉上下文

一句话：
> **Agent Teams 不是为了更聪明，而是为了更可交付。**

如果你愿意，我们可以用同一个任务做 A/B 实验：
- 单 agent vs A+B+C 并行
- 对比轮次 / 返工 / 可运行率

这样你就能知道自己的“性价比阈值”在哪里。
