# Claude Code 高级技巧盘点：技巧不是提示词，是工作流

> 这是一篇“我在把 Claude Code 用顺手的路上”的笔记。
> 结论先说：所谓高级技巧，很多不是让模型更聪明，而是让**你的交付过程更可验收**。

## 读者预期
如果你：
- 最近两三周才开始用 Claude Code（或任何 agentic coding 工具）
- 主要拿它做 **写新功能**、**读代码/理解系统**（偶尔修 bug/补测试）
- 之前用 Codex 更久，感觉很多经验相通但不知道怎么迁移

这篇就是给你“把经验结构化”的。

## 一句话主张
把“技巧”拆成四类：**提示词 / 工具 / 流程 / 验收**。你会发现：
- 提示词技巧很少，但很关键
- 真正决定稳定性的，是流程与验收（尤其是 checkpoint + DoD）

---

## 0) 开场：你以为你在学提示词，其实你在学项目管理
我一开始学 Claude Code 的方式很像“背技巧”：
- 看到别人说“先让它列 plan”就照做
- 看到别人说“让它先跑测试”就照做
- 看到别人说“让它写变更摘要”也照做

但用了一阵子我才发现：这些东西更像**工程团队的工作纪律**，不是“更强提示词”。

所以本文把“技巧”定义得更工程一点：
- 可复用（同类任务都能用）
- 可解释（知道它解决什么失败模式）
- 可验收（你能明确判断“做到没”）

---

## 1) 四类技巧：从玄学清单到可操作系统

### 1.1 提示词类（少而关键）
> 目标：让 Claude Code 不要“自作主张”，而是“在约束内交付”。

**技巧 1：先写清 DoD（Definition of Done）**
- 适用：几乎所有任务，尤其“加功能/改行为”
- 怎么做（可复制模板）：
  - “完成标准：1) 通过哪些测试；2) CLI 输出长什么样；3) 文档是否更新；4) 不允许改动哪些接口/依赖。”
- 解决的失败模式：它写了很多代码，但你没法判断算不算完成

**技巧 2：把约束说成‘禁止项’，而不是‘建议项’**
- 适用：你不想它引入新依赖、不想它改公共 API
- 模板：
  - “禁止：引入新依赖；禁止：改 public API；禁止：更换框架；只允许在 X/Y 两个目录内改动。”

**技巧 3：先问 3 个澄清问题（但别无限问）**
- 适用：你自己也不确定需求细节、或者代码库很复杂
- 模板：
  - “在开始写代码前，请先问我 3 个必须确认的问题；问完后给一个 5 步以内的计划。”

> 经验迁移（Codex ↔ Claude Code）：提示词类基本完全相通。

---

### 1.2 工具类（让它像工程师，不像聊天机器人）
> 目标：把“感觉对了”变成“证据对了”。

**技巧 4：强制它先读，再改（read-before-write）**
- 适用：读代码/理解系统、接手陌生 repo
- 模板：
  - “先定位相关文件并逐段解释：入口在哪里、数据怎么流、边界条件是什么；不要立刻改。”

**技巧 5：每次改完必须跑一个最小验证命令**
- 适用：写新功能/小改动
- 模板：
  - “每次提交 patch 前必须跑：unit tests / lint / typecheck（选一个最小集合）。把命令和结果贴出来。”

**技巧 6：让它写变更摘要（changelog-style）**
- 适用：你要快速 review
- 模板：
  - “最后用三段写：改了什么；为什么这么改；潜在风险/回滚方式。”

> 经验迁移：Codex 更像“可控的执行器”；Claude Code 很擅长把工具链串起来。

---

### 1.3 流程类（最容易被误当成提示词技巧）
> 目标：降低长任务的失控概率。

**技巧 7：把大任务拆成 3 个可交付子任务**
- 适用：写新功能（2 类任务的主力）
- 模板：
  - “把任务拆成 3 个 PR 级别的小交付（每个都能独立验证）。先列拆分方案，我确认后再做第 1 个。”

**技巧 8：设 checkpoint（每 15–30 分钟必须产出 artifact）**
- 适用：你觉得它开始“写很多但不落地”
- artifact 例子：
  - 跑通一个最小测试
  - 给出可执行的复现步骤
  - 输出一段准确的架构图文字版（入口/边界/依赖）

**技巧 9：并行分工（如果你在用 agent teams 或手动多窗口）**
- 适用：读代码 + 写功能同时进行
- 分工模板：
  - Agent A：读代码并画出数据流
  - Agent B：写实现（在 A 的结论基础上）
  - Agent C：补测试/验收脚本

> 经验迁移：这是 Claude Code 最近最“像新物种”的地方——把工程活动变成可并行的流水线。

---

### 1.4 验收类（决定返工次数的那部分）
> 目标：把“交付”变成“可验收交付”。

**技巧 10：用测试/场景当契约（单测或 BDD 都可以）**
- 适用：功能需求容易扯皮
- 模板：
  - “先写 5 条 Given/When/Then 场景（或 3 个单测），我确认后再实现。”

**技巧 11：用 diff review 的姿势验收**
- 适用：任何改动
- 模板：
  - “请按文件列出改动点，并说明：为何必要、可能副作用、如何回滚。”

**技巧 12：失败要有‘回滚 + 复盘’**
- 适用：它改坏了东西或引入隐性风险
- 模板：
  - “回滚到上一个可通过测试的状态；然后写一段复盘：失败原因、下次怎么避免、需要哪些 guardrail。”

---

## 2) 一个可复现实验：ablation，找出“最值钱的 3 条”
你说你之前用 Codex 多一些、最近才用 Claude Code——这很容易陷入“凭手感换工具”的陷阱。

我更推荐一个工程化做法：**ablation（逐条加技巧，看边际收益）**。

### 2.1 实验目标
- 找出对你最有用的 3 条技巧（不是对别人最有用的）

### 2.2 实验任务（建议选 2/3 类任务）
因为你以“写新功能 + 读代码”为主，我建议固定一个中等任务，例如：
- 在一个 repo 里新增一个小功能（带最小 CLI / API）
- 同时需要读清楚入口与数据流

> 如果你暂时不想选外部 repo，也可以用 real-world-ai-log：比如给我们现有脚本补一个“dry-run + 报告输出”。

### 2.3 变量与对照
- Baseline：只给目标，不给技巧
- 每轮只加 1 条技巧（例如：先加 DoD，再加 read-before-write，再加 checkpoint）

### 2.4 记录指标（别太多，够用就行）
- 首轮可运行率（一次跑通/一次能用）
- 返工次数（你纠正它多少次）
- 交互轮次（你说了多少轮才收敛）
- 最终质量（你主观 1-5 分 + 是否通过测试）

### 2.5 预期输出
- 一张“边际收益排序”（哪 3 条最值钱）
- 以及它们的适用条件（什么时候加、什么时候不必加）

---

## 3) 一页 SOP（我现在默认这样用 Claude Code）
> 你可以把它当成每天开工前的 checklist。

1) **目标 + DoD + 禁止项**（30 秒写清楚）
2) **Read-before-write**：先定位入口/相关文件（尤其是新 repo）
3) **计划 ≤ 5 步**：我确认后再动手
4) **实现**：小步提交，别一口气写到爽
5) **最小验证**：跑一个命令/一组测试
6) **总结**：改了什么、为什么、风险与回滚

---

## 结尾：技巧的本质是把不确定性变成可验收的步骤
对我来说，Claude Code 和 Codex 的共同点是：
- 你越把任务变成“可验收的步骤”，它越像一个靠谱同事

下一步（如果你愿意）：我们就用这篇文章的 ablation 方法，选一个你正在做的新功能任务，跑出你自己的“最值钱 3 条技巧”。
