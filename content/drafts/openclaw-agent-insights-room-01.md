# 洞察室（01）OpenClaw：把个人助理做成“可编排系统”

> 这不是一篇产品评测。
> 我们要研究的是：一个优秀 agent 系统，哪些设计值得我们借鉴到自己的工作流里。

## 为什么从 OpenClaw 开始（以及为什么要做“洞察室”）
在这个公众号项目里，我（和你）踩过一个很现实的问题：

- 你曾尝试用 **agent API** 搭自动化，但卡在“数据入口”：比如 **X 的 API 太贵**，抓取是绕不过去的。
- 你也用过 **Happy + Claude Code** 跑项目，但因为权限/网络限制，需要 **VPS + 本地电脑两处接力**，再用 GitHub 同步资料与中间产物。
- 这套接力工作流能跑起来，但它的“痛点”很清楚：**缺少定时执行**（以及一些更隐性的：可审计、可恢复、跨通道投递的确定性）。

所以“洞察室”系列的目标不是追热点，而是做一个**可复用设计样本库**：
- 看到一个工具做对了什么，我们就把它拆成模式；
- 能复现的就复现；
- 能迁移到自己的写作/工程工作流的，就迁移。

首发选 OpenClaw，因为它刚好覆盖了我们最关心的那条链路：
**数据抓取 → 生成内容 → 定时触发 → 自动投递 → 可回溯与维护**。

---

## 一句话理解 OpenClaw
OpenClaw 更像一个 **runtime**：
- “聊天”只是入口
- 真正让它能干活的是：**通道（channels）+ 会话（sessions）+ 工具（tools）+ 定时任务（cron）+ 记忆（memory）**

如果只把它当 bot，会看不懂；把它当 runtime，很多设计就顺了。

---

## 1) 核心架构：把 agent 当 runtime，而不是“更聪明的聊天框”
如果只用“聊天”去理解 OpenClaw，你会觉得它和别的 bot 差不多；
但把它当 runtime，你会看到它把很多“人肉接力”的问题，变成了系统组件：

- **Gateway**：进程级的运行时（负责把各种 channel 的收发、工具调用、定时任务跑起来）
- **Channels**：消息入口/出口（Discord、WhatsApp…）
- **Sessions**：上下文与任务的承载单元（让不同通道/不同对话不互相污染）
- **Tools**：真正的能力边界（exec / browser / web_fetch / message / cron…）
- **Cron**：事件驱动与定时执行（把“每天 07:00”从提醒变成默认行为）
- **Memory**：把规则与关键事实落盘，避免“只有人记得”

这一套东西组合起来，OpenClaw 才能做我们最需要的那种“杂活自动化”：
**抓数据 → 产出内容 → 定时触发 → 自动投递 → 可回溯**。

---

## 2) 工具系统：能力来自边界，而不是模型更聪明
我们很容易把体验差异归因到模型（Codex / Claude / Gemini 谁更强），但在“杂七杂八”的工作里，差异往往来自：

- 它能不能**稳定地调用工具**（执行命令、读写文件、抓网页、发消息）
- 它有没有**权限边界**（哪些动作需要审批/确认）
- 它能不能把过程**落盘**（截图、日志、JSON 产物）

我们这次链路里，关键工具非常具体：
- **Playwright**：抓取 X / 操作 WeChat（绕开 X API 成本问题）
- **message**：把结果确定地投递回 WhatsApp
- **cron**：让“每天 07:00”变成系统行为

工具边界清晰的直接收益是：
- 失败不会玄学化，而是变成可定位的错误（cookie 失效、找不到按钮、超时等）
- 你可以逐步增强系统，而不是推倒重来

对照 Happy + Claude Code：你之前那套“VPS + 本地接力 + GitHub 同步”，本质上是把 runtime 缺失的部分交给人去完成。

---

## 3) 通道与会话：为什么它能同时处理 Discord/WhatsApp 而不乱
我们这次实践里，一个直接收益是：
- Discord 跑着不影响 WhatsApp 接入
- WhatsApp 可以设置 allowlist，只允许你的号码，群禁用

这种“多通道不互相污染”的能力，来自一个朴素但很强的拆分：
- **channel 负责收发**
- **session 负责上下文**
- 回复默认“回到原通道”，不需要你额外操心

把它换成一句人话：
> 你不用再手工管理“这一步产物在哪、下一步去哪执行、结果怎么发回来”。

---

## 4) 交互设计：技巧不是提示词，是“闭环”
我觉得 OpenClaw 在交互上有一个很工程化的默认：**小步、可审阅、产出 artifact**。

你也能看到一个很关键的区分：
- **system event（提醒/触发）**：像“开始工作”的按钮
- **user message（任务/对话）**：像“具体需求”

这个区分后面会在 cron 的坑里变得很重要。

---

## 5) 定时任务（cron）：从“提醒我”到“自动交付”的关键差异
这是我们今天最值得写下来的坑：

一开始，我们的 07:00 任务确实按时触发了（上海时区没问题），但你没有收到内容。
原因不是时区，也不是我偷懒，而是一个设计层面的差异：

- 旧版本 cron 做的是：07:00 发一个 **systemEvent** 到主会话 —— 本质是“提醒我去做流程”
- 你真正想要的是：07:00 自动抓取 → 总结 → 直接发 WhatsApp —— 本质是“自动交付”

把 cron 从提醒升级成自动交付，我们做了两件事：
1) 让 cron 跑在 isolated agentTurn（自包含地完成任务）
2) deliver 目标指向 WhatsApp（把结果直接投递给你）

这件事很小，但它区分了“工具能用”与“系统能跑”：
- 能用：你随时能让它做一次
- 能跑：它能在你不盯着的时候持续产出

对比 Happy + Claude Code：你说得很准——它“其他都能搞定”，但缺少定时执行，就很难变成一个持续运转的系统。

---

## 6) 记忆（memory）：不是越多越好，而是可控、可检索
OpenClaw 在记忆上的一条很实用的取舍是“分层”：
- 长期：MEMORY.md（经过筛选的长期事实/偏好/项目规则）
- 每日：memory/YYYY-MM-DD.md（当天发生了什么，作为流水账）

它的价值不在“记得更多”，而在：
- 你能控制写入什么
- 你能追溯“为什么我现在这么做”（规则在文件里，不在脑子里）

对于做内容项目，这特别重要：
- 你的规则会越来越多
- 不落盘就会变成“只有你记得的潜规则”，无法规模化

---

## 7) 我们从 OpenClaw 借走的 5 个设计模式（本篇结论）

1) **把工作拆成可验收的闭环**：计划 → 执行 → 验收/投递 → 落盘
2) **通道与会话分离**：跨 Discord/WhatsApp 仍能确定地路由回复
3) **工具边界就是能力边界**：把“杂活”变成工具调用，而不是寄希望于模型灵感
4) **cron 要做“自动交付”，别只做“提醒”**：生成与投递必须在同一个 job 里闭环
5) **记忆分层 + 规则落盘**：减少“接力工作流”对人的依赖

---

## 8) 可复现实验：把“每日选题”做成系统能力
我们已经跑通了一个最小实验（可继续优化）：
- 每天 07:00（Asia/Shanghai）
- 抓取 X For You 50 条（cookie + Playwright，避免 API 成本）
- 生成 4–6 个选题 + 1 个推荐方向
- 自动投递到 WhatsApp

如果你想复现，最小步骤长这样（不贴任何 cookie 内容）：

1) 确保 X cookie 文件已存在（Netscape cookies.txt 格式）
2) 抓取 50 条：
   - `node /home/fei/clawd/x-for-you-20.mjs <cookieFile> <outDir> 50`
3) 让 cron 在 07:00 跑一个“自包含交付”的 job：抓取 → 总结 → message 发送到目标 WhatsApp

建议记录 3 个指标，用来判断系统是否“真的可用”：
- **准时性**：是否按时到（不需要你盯）
- **稳定性**：失败原因是否可见（cookie 失效要明确说）
- **可维护性**：需求改一次，需要改几处（越少越好）

---

## 结尾：下一期写什么
下一期我建议用同一套维度对照一个“更偏写代码”的工具（例如 Cursor 或 OpenCode），把你的刻板印象也拿来验证：
- 它们真的是“只擅长写代码”吗？
- 还是缺的是“定时/通道/投递/审计”这类 runtime 能力？

如果你同意，我们下一期就选 Cursor，做一篇“使用方法 70% + 设计拆解 30%”的对照。
