# Agent 的上下文工程：一套正在形成事实标准的目录结构

最近在 X 上看到一个挺有意思的“巧合”：

不同朋友在做不同场景的 Agent（写作、开发、知识管理），最后不约而同都落到同一套文件规范里：

- `SOUL.md`
- `USER.md`
- `SKILLS.md` / `skills/`
- `MEMORY.md`

看起来像是社区自发的“玄学仪式感”。但我越做越觉得：这不是巧合，而是工程约束下的**最小可行解**。

这篇文章我想把它讲清楚三件事：
1) 为什么会收敛到这套结构；
2) 每个文件到底该写什么、不该写什么；
3) 以及最关键的：怎么让它持续更新，变成一套系统。

---

## 0. TL;DR：你可以先抄一份最小模板

如果你只想先用起来，先抄这个（10 分钟版）：

```text
project/
  SOUL.md
  USER.md
  MEMORY.md
  skills/
    README.md
```

- `SOUL.md`：定义你希望 Agent 成为什么样的协作者（原则、语气、边界）。
- `USER.md`：定义它服务谁（偏好、禁忌、作息、确认机制）。
- `skills/`：定义它能做什么（可调用的动作、参数、失败处理）。
- `MEMORY.md`：定义它要长期记住什么（决策、踩坑、长期 TODO）。

下面我会解释为什么这四个文件几乎是“必然出现”的。

---

## 1. 为什么大家会收敛到同一套“上下文系统”？

一句话：

> Agent 的产出质量 = 模型能力 × 上下文质量。

很多时候我们以为问题在“模型不够强”，但真正的痛点常常是：
- 同一个任务，你每次对 Agent 的要求其实不一样；
- 你的偏好/边界/禁忌没有被写下来；
- 关键决策散落在聊天里，隔天就找不到了；
- 一旦换模型/换工具，就要从头解释一遍。

当你开始把 Agent 当成长期协作者，而不是一次性问答工具时，你会自然遇到三类工程需求：

1) **可维护**：要能迭代、能 diff、能 review。
2) **可迁移**：换模型/换环境/换工具，核心上下文不丢。
3) **可审计**：失败能回放、能复盘，知道“为什么这次坏了”。

这三类需求会把人推向同一个答案：用一组结构化的、可版本化的文本文件，把“隐性知识”变成“显性约束”。

而 `SOUL/USER/SKILLS/MEMORY` 恰好覆盖了最常见的四类信息：
- 价值观与行事原则（SOUL）
- 用户偏好与边界（USER）
- 能力接口与操作流程（SKILLS）
- 连续性与长期状态（MEMORY）

---

## 2. 四个文件分别解决什么问题（以及不写会怎样）

### 2.1 SOUL.md：你希望它“成为什么样的人”

`SOUL.md` 解决的是“风格一致性”和“判断标准一致性”。

你应该写：
- 做事原则（比如：允许失败，但不允许含糊）
- 输出风格（实操优先、不端着、不权威）
- 边界（什么必须先问、什么不能擅自做）

你不该写：
- 一次性的任务细节
- 任何账号/密码/cookie

没有 `SOUL.md` 的典型后果：
- 每次输出像随机抽卡：有时很谨慎，有时很“自信胡扯”。
- 你越用越累，因为你要反复纠正它“应该怎么说、怎么做”。


### 2.2 USER.md：它在服务谁（偏好、禁忌、作息、确认机制）

`USER.md` 是“协作协议”。

你应该写：
- 称呼、语气偏好
- 安静时间（比如夜里不主动发消息）
- 对外发送必须确认（邮件/社交媒体/群里代言等）
- 决策规则（比如：除了选题/大纲方向，其他小问题 10 分钟不回复就默认推进）

没有 `USER.md` 的典型后果：
- 它会在你不想被打扰的时候打扰你。
- 它会在你没授权的时候“替你做决定”。


### 2.3 SKILLS.md / skills/：它到底能做什么（以及怎么做）

只靠聊天，你永远在“重复解释”。

`skills/` 解决的是“把会做，变成可调用”。

你应该写：
- 固定流程的接口：输入是什么、输出是什么
- 参数：哪些可调、默认值是什么
- 失败策略：失败时先截图/保存日志/重试几次
- 安全约束：敏感信息不写入 repo、cookie 当作凭证处理

没有 `skills/` 的典型后果：
- 每一次成功都像“临时发挥”，下次复现不了。
- 你很难形成一条稳定流水线，只能靠你自己盯着。

> 顺便说一句：你可以把 skills 理解成“能被复用的工作流单元”。它可以是文档、脚本、也可以是更正式的工具协议（比如 MCP）。但它们解决的核心问题一样：把过程变成资产。


### 2.4 MEMORY.md：连续性与状态（不是聊天记录备份）

`MEMORY.md` 的目标不是“记住所有细节”，而是记住**长期有效的东西**。

适合写进 memory 的：
- 关键决策（比如：服务器无 GUI → 选择 Playwright headless + cookie 注入）
- 稳定路径（某个脚本/目录/命令是标准做法）
- 偏好与边界（比如 quiet hours）
- 复用价值高的坑（比如某个选择器易碎，要怎么定位）

不适合写的：
- 一次性临时信息
- 可以从 git 追溯的细节（commit 已经说明了就不重复）

没有 `MEMORY.md` 的典型后果：
- 你会反复踩同一个坑。
- 你会反复讲同一段背景。
- 一旦换会话/换工具，“协作者”就像失忆。

---

## 3. “事实标准”背后的工程约束：为什么这套结构特别耐用

这套结构之所以会成为事实标准，是因为它天然符合软件工程的三个优点：

- **可版本化**：文本文件可 diff、可 review、可回滚。
- **可迁移**：换模型/换工具时，把这四个文件搬过去就能恢复大部分协作体验。
- **可审计**：失败时能追问：是哪条规则没写清？是哪一步流程没固化？

另外还有一个现实约束：**安全**。

当你开始做自动化（例如登录、发消息、发布内容），cookie/凭证/账号信息就会出现。
如果没有清晰的结构和边界，你很容易把“凭证”和“可公开复用的流程”混在一起。
而把它们分到不同的文件/目录，本质上是在做最简单的“权限分层”。

---

## 4. 最小可用模板（你可以直接复制粘贴）

下面是一套我觉得足够小、也足够用的骨架。

### SOUL.md（示例）
```markdown
# SOUL
- 基调：实操优先、克制、不端着
- 原则：允许失败，但不允许含糊
- 输出：尽量给可执行的下一步和可验证的产物
- 边界：任何对外发送/发布动作必须先确认
```

### USER.md（示例）
```markdown
# USER
- 时区：Asia/Shanghai
- 安静时间：23:00–07:00 不主动发消息
- 决策规则：选题/大纲方向必须确认；其他小问题 10 分钟无回复默认推进
```

### skills/README.md（示例）
```markdown
# skills
这里放可复用流程：
- 输入/输出
- 参数与默认值
- 失败处理与截图/日志
- 安全约束（cookie 等凭证不得进入 repo）
```

### MEMORY.md（示例）
```markdown
# MEMORY
- 关键决策
- 稳定路径（命令/脚本/目录）
- 长期 TODO
- 踩坑总结（以后不能再踩）
```

---

## 5. 更新机制：把“写文件”变成“系统”

很多人搭完目录就结束了，但真正的价值来自持续更新。

我推荐一个简单的复盘触发器：每次任务结束，问自己 4 个问题——

1) **哪个判断标准被反复用到？** → 写进 `SOUL.md`
2) **哪个偏好/禁忌被触发？** → 写进 `USER.md`
3) **哪个步骤可以复用/自动化？** → 写进 `skills/`
4) **哪个坑以后不能再踩？** → 写进 `MEMORY.md`

然后给它一个节奏：
- daily：随手记 3 行
- weekly：把 daily 蒸馏进 `MEMORY.md`
- monthly：做一次系统复盘（甚至让 Agent 帮你读历史记录给建议）

你会发现：只要你坚持一段时间，“上下文系统”就会像代码一样越来越稳。

---

## 6. 一个真实案例：我们怎么用这套结构跑通「X → 公众号草稿箱（含图片）」

我们最近在做一个很具体的目标：

> 在没有 GUI 的服务器上，把“从 X 看到热点 → 产出文章 → 配图 → 保存到公众号草稿箱”做成全自动流水线。

这个任务天然会暴露出上下文缺失的问题：
- 登录要 cookie 注入（cookie 是凭证，必须当作敏感信息）
- Playwright 选择器很脆（失败要截图，流程要可复现）
- 文章写作要有一致风格（不能权威口吻，必须实操）

我们最终沉淀出来的产物大概是：
- `content/ideas → outlines → drafts → published`：写作流水线
- `scripts/wechat-*.mjs` + `.docs/workflows/`：可复用的操作技能
- `progress/`：过程记录
- `MEMORY.md`：关键决策、路径、TODO

这就是“事实标准”的价值：
它把一次成功变成可复现资产，把一次失败变成可避免的坑。

---

## 7. 结尾：下一步怎么做

如果你想把 Agent 当作长期协作者，我建议你不要再追求“一次性完美提示词”。

从这四个文件开始，先搭一个最小上下文系统，然后用一次真实任务去磨它。

下一篇我会用这套上下文系统，从 0 跑一遍真实任务：
**选题 → 大纲 → 草稿 → 配图 → 草稿箱**，并把每一步的沉淀点写清楚。

如果你已经有自己的版本，也欢迎你对照看看：
你缺的是哪一块？你是靠什么机制在更新它？
